API Usage Analysis
Overview
The project uses the Riot Games API to fetch League of Legends player data through a Netlify serverless function proxy. The API integration enables users to search for summoner profiles, view ranked statistics, and monitor server status.

Architecture
Netlify Function Proxy (netlify/functions/riot-api.js)
The API implementation uses a serverless function that acts as a secure proxy between the frontend and Riot Games API:

Key Features:

Environment Variable Security: API key stored in RIOT_API_KEY environment variable, never exposed to client
Dynamic Region Support: Accepts region query parameter (e.g., NA1, EUW1, KR) to route requests to regional endpoints
Flexible Endpoint Routing: Uses endpoint query parameter to specify Riot API paths dynamically
Response Caching: Implements 5-minute cache (Cache-Control: public, max-age=300) to reduce API calls
Error Handling: Returns structured JSON errors for missing configurations, invalid requests, or API failures
Request Flow:

Frontend calls /api/riot-api?endpoint=/lol/summoner/...&region=na1
Netlify redirect rule routes /api/* to /.netlify/functions/:splat
Function constructs full Riot API URL: https://{region}.api.riotgames.com{endpoint}
Request authenticated with X-Riot-Token header
Response proxied back to client with appropriate status codes
Netlify Configuration (netlify.toml)
The redirect configuration enables clean API URLs:

from = "/api/*"
to = "/.netlify/functions/:splat"
This maps /api/riot-api → /.netlify/functions/riot-api transparently.

Frontend Implementation
Summoner Selector (public/Summoner-Selector.html)
The summoner selector page makes three distinct API calls:

1. Server Status Check (Lines 133-159)
/api/riot-api?endpoint=/lol/status/v4/platform-data&region={region}
Purpose: Fetches platform status including maintenance schedules and incidents
Trigger: Automatically on page load and when region changes
Response Handling:
Green status: "All systems operational"
Orange warning: Shows maintenance count
Red alert: Displays incident count
Error Handling: Displays "Unable to check server status" on failure
2. Summoner Profile Lookup (Lines 169-172)
/api/riot-api?endpoint=/lol/summoner/v4/summoners/by-name/{name}&region={region}
Purpose: Retrieves summoner account information by name
Data Retrieved: puuid, id, summonerLevel, profileIconId, name
Trigger: User clicks "Search" button or presses Enter in input field
Name Processing: Trims whitespace, removes # tags, normalizes spaces
Profile Display: Updates icon from Data Dragon CDN (ddragon.leagueoflegends.com)
3. Ranked Statistics (Lines 177-178)
/api/riot-api?endpoint=/lol/league/v4/entries/by-summoner/{id}&region={region}
Purpose: Fetches ranked queue information for the summoner
Data Retrieved: Array of ranked entries (Flex, Solo/Duo)
Filtering: Extracts RANKED_SOLO_5x5 queue type specifically
Display: Shows tier, rank, and LP (e.g., "GOLD II · 73 LP") or "Unranked"
Data Flow:

User enters summoner name → Fetch summoner profile
Extract summoner.id from response → Fetch ranked stats
Combine data → Display in UI and store in localStorage
Home Room (public/homeroom.html)
The home room page includes a "League Profile" mini-app within the PC hotspot:

League Profile App (Lines 1226-1273)
/api/riot-api?endpoint=/lol/summoner/v4/summoners/by-name/{name}&region=na1
/api/riot-api?endpoint=/lol/league/v4/entries/by-summoner/{id}&region=na1
Purpose: Displays full summoner profile within in-game PC interface
Default Profile: Loads "Faker" as example (line 1224)
Trigger: Clicking the League app icon in desktop (line 1277-1280)
Display Elements:
Summoner icon and level
Rank tier and LP
Win/loss record and winrate calculation
Favorite champion section (placeholder)
Error Handling: Console logging with fallback UI messages
API Endpoints Used
Status API
Endpoint: /lol/status/v4/platform-data
Regions: All (dynamic based on user selection)
Usage: Automatic status monitoring
Summoner API
Endpoint: /lol/summoner/v4/summoners/by-name/{summonerName}
Regions: All (user-selected)
Usage: Profile searches in Summoner Selector and Home Room
League API
Endpoint: /lol/league/v4/entries/by-summoner/{encryptedSummonerId}
Regions: All (user-selected)
Usage: Ranked statistics display
Data Persistence
LocalStorage Integration
The application stores fetched summoner data in browser localStorage:

Stored Object Structure:

{
  name: string,
  id: string,
  puuid: string,
  level: number,
  profileIconId: number,
  region: string,
  rank: {
    tier: string,
    rank: string,
    leaguePoints: number
  } | null
}
Key: "selectedSummoner"

Usage Points:

Saved when user clicks "Save" button (line 224-231)
Auto-saved before navigation to home room (line 240-242)
Auto-restored on page reload (line 246-269)
Regional Support
Supported Regions (15 total):

Americas: NA1, BR1, LA1, LA2
Europe: EUW1, EUN1, TR1, RU
Asia: KR, JP1, OC1, TW2, VN2, SG2, ME1
Each region has its own rate limit tracking and endpoint routing through the Riot API regional infrastructure.

Error Handling Strategy
Function-Level Errors:

Missing API key → 500 with descriptive message
Missing endpoint param → 400 bad request
Fetch failures → 500 with error details
Client-Level Errors:

API failures → Display error message in UI
Invalid summoner → "Summoner not found" status
Network errors → Graceful fallback with console logging
State Management:

Failed requests clear currentSummoner variable
Save button disabled on errors
Previous valid data retained in localStorage
Rate Limiting Considerations
The Riot API implements rate limiting headers visible in the function responses:

X-App-Rate-Limit: Application-level limits (100 requests per 2 minutes)
X-Method-Rate-Limit: Endpoint-specific limits (20,000 per 10 seconds)
The 5-minute cache on the serverless function helps reduce redundant API calls within the allowed limits.

Security Implementation
Strengths:

API key never exposed to client-side code
Server-side validation of requests
No direct client access to Riot API
Architecture Benefits:

Centralized authentication through single function
Environment variable management through Netlify
CORS handling via serverless function proxy
Protection against API key theft or abuse
Data Flow Summary
User Action (Search/Navigate)
    ↓
Frontend JavaScript (fetch call)
    ↓
Netlify Redirect (/api/* → /.netlify/functions/*)
    ↓
Serverless Function (riot-api.js)
    ↓
Riot Games Regional API (https://{region}.api.riotgames.com)
    ↓
Response with Cache Headers
    ↓
Frontend Display + LocalStorage
This architecture ensures secure, performant, and maintainable integration with the Riot Games API while providing a seamless user experience across the summoner selector and home room interfaces.
